# 1. 设计模式是什么？

是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。
一句话总结：**是前人所总结出的解决特定问题的经验和套路，是一种代码设计经验，具有一定普遍性，可以反复使用。**

* **创建型模式**

  用于描述**“怎样创建对象”**，它的主要特点是“将对象的**创建与使用分离**”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。

* **结构型模式**

  用于描述如何将类或对象按某种布局组成更大的结构(**"流程控制"** 和 **”类间合作任务分配"**)，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。

* **行为型模式**

  用于描述类或对象之间怎样**相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责**。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。



# 2. 创建型模式

将对象 *创建* 与 *使用* 分离。

## 1. 单例模式(重点)

一个类提供创建一个单一的实例对象(每次调用获得的都是同一个对象)，且可以直接调用不用实例化。

- 私有化构造器
- 创建静态实例化变量：private static Object object
- 对外提供 static 静态方法返回该静态变量
- 实例化变量：
  - 饿汉式(直接实例化) 
  - 懒汉式(调用时候创建，但得注意线程安全) 
  - 枚举类方式
  - 内部类



**饿汉式**：

``` java
public class Sigton
{
    private static Object object = new Object();
    
    private Sigton() {}
    
    public static Object getSigleInstance()
    {
        return object;
    }
}
```


**懒汉式：**
方式一：线程不安全。

``` java
public class Sigton
{
    private static Object object;
    
    private Sigton() {}
    
    public static Object getSigleInstance()
    {
        if (object == null)
        {
            object = new Object();
        }
        return object;
    }
}
```

方式二：线程安全(加锁)
``` java
public class Sigton
{
    private static Object object;
    
    private Sigton() {}
    
    public static synchronized Object getSigleInstance()	// 加锁保证单线程调用
    {
        if (object == null)
        {
            object = new Object();
        }
        return object;
    }
}
```

方式三：双检加锁(相比上面，如果并发度高，初始化时候会提高速度)
``` java
public class Sigton
{
    private static Object object;
    
    private Sigton() {}
    
    public static synchronized Object getSigleInstance()
    {
        if (object == null)
        {
			synchronized(this.class)	// 加锁的位置永远是单线程的
            {
                if (object == null)
                {
                    object = new Object();
                }
            }
        }
        return object;
    }
}
```

**枚举类**：也属于饿汉式

``` java
public enum Singleton
{
    single("张三", 18);
    
    public String name;
    public int age;
    
    private Singleton(String name, int age)
    {
        this.name = name;
        this.age = age;
    }
}

public enum Singleton
{
    single;	// 没有成员变量
}


// 调用
public static void Test
{
    public void static main(int []args)
    {
        System.out.println(Singleton.single.name);
        System.out.println(Singleton.singleage);
    }
}
```

**内部类：**
静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 `static` 修饰，保证只被实例化一次，并且严格保证实例化顺序。

``` java
/**
 * 静态内部类方式
 */
public class Singleton {

    //私有构造方法
    private Singleton() {}

    private static class SingletonHolder {	// static 保证只被加载一次，又因为是内部类，所以只有父类记载才会加载。Final 保证不会被修改。
        private static final Singleton INSTANCE = new Singleton();
    }

    //对外提供静态方法获取该对象
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```



**真实实例应用：**Runtime 源码

``` java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    /**
     * Returns the runtime object associated with the current Java application.
     * Most of the methods of class <code>Runtime</code> are instance
     * methods and must be invoked with respect to the current runtime object.
     *
     * @return  the <code>Runtime</code> object associated with the current
     *          Java application.
     */
    public static Runtime getRuntime() {
        return currentRuntime;
    }

    /** Don't let anyone else instantiate this class */
    private Runtime() {}
    ...
}
```



## 2. 工厂模式(重点)

将实例化的操作都交给工厂进行调用，避免了修改时候 客户端代码的频繁修改 ，提高了代码的灵活性，实现了解耦，符合闭合原则(可插拔)。



**普通的方式：**
![](E:\学习学习\Java学习资料\java设计者模式\第一章-02-创建者模式-工厂模式\笔记\img/工厂设计模式引入.png)

缺点：客户端代码进行判断实例化，new的操作都在客户端（CoffeeStore)，耦合度太大，一发而动全身。



**简单工厂**：抽象产品，具体产品，但只有一个具体工厂

![简单工厂模式](E:\学习学习\Java学习资料\java设计者模式\第一章-02-创建者模式-工厂模式\笔记\img\简单工厂模式.png)

缺点：虽然解除了一定的耦合性(将new的操作放在工厂类中)，但是判断的操作还是在工厂中所以每次新增 coffe 就得修改工厂类，即还是存在耦合。



### **工厂方法模式**

根据上面的分析，单个工厂类肯定不行还是存在耦合。
所以设计如下结构，将工厂类也进行了抽象。![工厂方法模式](E:\学习学习\Java学习资料\java设计者模式\第一章-02-创建者模式-工厂模式\笔记\img\工厂方法模式.png)

* **抽象工厂**（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。
* **具体工厂**（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
* **抽象产品**（Abstract Product）：定义了产品的规范，描述了产品的主要特性和功能。
* **具体产品**（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

抽象产品：


``` java
public abstract class Coffee {

    public abstract String getName();

    //加糖
    public void addsugar() {
        System.out.println("加糖");
    }

    //加奶
    public void addMilk() {
        System.out.println("加奶");
    }
}
```

具体产品：

``` java
public class AmericanCoffee extends Coffee {

    public String getName() {
        return "美式咖啡";
    }
}
```

抽象工厂：
 ``` java
 public interface CoffeeFactory {
 
     //创建咖啡对象的方法
     Coffee createCoffee();
 }
 ```

具体工厂:
``` java
public class AmericanCoffeeFactory implements CoffeeFactory {

    public Coffee createCoffee() {
        return new AmericanCoffee();
    }
}

public interface CoffeFactory
{
    Coffee createCoffee();
}

public AmericanCoffee implements CoffeFactory
{
   public Coffee createCoffee()
   {
       return new AmericanCoffee();
   }
}
```


注意：调用时候是调用 具体工厂类 ，对应的 产品 生产也在 工厂类 中。

优点：符合 开闭原则 实现了热插拔，一个从长具体类 对应着一个 产品。

缺点：增加了系统的复杂性，每增加一个 产品 就得对应增加一个 工厂 类。



### 抽象工厂模式

将上面的 **单产品** 改为 **多产品** 即 **一个工厂对应多个产品**

![抽象工厂模式](E:\学习学习\Java学习资料\java设计者模式\第一章-02-创建者模式-工厂模式\笔记\img\抽象工厂模式.png)

* **抽象工厂**（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。
* **具体工厂**（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
* **抽象产品**（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
* **具体产品**（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。



只需要修改对应的抽象工厂，增加对应的依赖:

抽象工厂：

``` java
public interface DessertFactory {

    //生产咖啡的功能
    Coffee createCoffee();

    //生产甜品的功能
    Dessert createDessert();
}
```

具体工厂：
``` java
public class AmericanDessertFactory implements DessertFactory {

    public Coffee createCoffee() {
        return new AmericanCoffee();
    }

    public Dessert createDessert() {
        return new MatchaMousse();
    }
}
```



注意：调用时候是调用 具体工厂类 ，对应的 产品 生产也在 工厂类 中。

优点：实现了单个工程可以生产 **产品族** 的产品。

缺点：增加了系统的复杂性，每增加一个 产品 就得对应增加一个 工厂 类。



###  缓存工厂(拓展)

利用反射 + 读取properties配置文件 + Map缓存对象 

工厂类：

``` java
/**
 *  工厂类 + 配置文件 + java动态加载
 */
public class CoffeeFactory {

    private static Properties properties = new Properties();   // 创建properties 文件对象
    private static Map<String, Coffee> container = new HashMap<>();    //这里类似有Spring的 Ioc 容器

    // 将所有的咖啡对象读取到容器中(静态代码块,在构造器执行之前执行)
    static {

        final InputStream inputStream = CoffeeFactory.class.getClassLoader().getResourceAsStream("bean.properties");

        try {

            properties.load(inputStream);

            final Set<Object> keys = properties.keySet();
            for (Object key : keys) {
                String className = (String) properties.get(key);
                final Class aClass = Class.forName(className);
                Coffee coffee = (Coffee) aClass.newInstance();
                container.put((String)key, coffee);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }

    }


    // 根据咖啡名称获取咖啡(但这里通过properties进行了解耦合，不用每次修改factory工厂类，而是修改properties就行了)
    public Coffee createCoffee(String name) {

        return container.get(name);
    }
}
```


调用：
``` java
public class CoffeeStore {

    // 通过抽象工厂获取对应的coffee，实现实现解耦(原本是传入咖啡名称然后根据名称进行判断创建对应的coffee，不符合开闭原则，如果要增加一个coffee就得修改所有的使用者)
    public void orderCoffee(String name) {

        final CoffeeFactory coffeeFactory = new CoffeeFactory();
        final Coffee coffee = coffeeFactory.createCoffee(name);
        System.out.println(coffee.getName());
        coffee.addMilk();
        coffee.addSugar();
    }
}
```



properties(咖啡名：全类名):
``` java
american=com.iron.Design.Demo02BuilderModel.Othre_P1_Properties.product.Extends.AmericanCoffee
latte=com.iron.Design.Demo02BuilderModel.Othre_P1_Properties.product.Extends.LatteCoffee
```



## 3. 原型模式

具体原型类 实现 Cloneable(原生) 接口 重写 clone 方法创建 实例对象。

![原型模式](E:\学习学习\Java学习资料\java设计者模式\第一章-02-创建者模式-工厂模式\笔记\img\原型模式.png)

* **抽象原型类**：规定了具体原型对象必须实现的的 clone() 方法。
* **具体原型类**：实现抽象原型类的 clone() 方法，它是可被复制的对象。
* **访问类**：使用具体原型类中的 clone() 方法来复制新的对象。




抽象原型类(原生标记接口)
``` java
public interface Cloneable {
}
```

具体原型类(实现标记Cloneable标记接口)

浅拷贝：

``` java
public class Realizetype implements Cloneable {
	int age;
    
    public Realizetype() {
        System.out.println("具体的原型对象创建完成！");
    }

    @Override
    protected Realizetype clone() throws CloneNotSupportedException {
        System.out.println("具体原型复制成功！");
        return (Realizetype) super.clone();
    }
}
```

深拷贝：
``` java
public class Realizetype implements Cloneable {
	int age;
    
    public Realizetype() {
        System.out.println("具体的原型对象创建完成！");
    }

    @Override
    protected Realizetype clone() throws CloneNotSupportedException {
        Realizetype realizetype = new Realizetype();
        realizetype.age = this.age;
        return realizetype;
    }
}
```



访问类：
``` java
Relizetype realizetype = new Relizetype();
relizetype.age = 10;

Relizetype clone = relizetype.clone();
System.out.println(cloe == relizetype); // 浅克隆：true 深克隆：false
```



优点：

* 对象的创建非常复杂，可以使用原型模式快捷的创建对象。
* 性能和安全要求比较高。

缺点：

- 得先创建一个对象，再进行克隆，有的场合不适用，而且对象的内容是一样的。



## 4. 建造者模式

将对象的 **构建** 和 **装配** 进行分离，即创建对象的时候是以 **装配类(Director)** 调用 **构建类(Builder)** 顺序进行创建的。

![image-20200413225341516](E:\学习学习\Java学习资料\java设计者模式\第一章-02-创建者模式-工厂模式\笔记\img\image-20200413225341516.png)

* **抽象建造者类（Builder）**：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的**部件对象的创建**。 

* **具体建造者类（ConcreteBuilder）**：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 

* **产品类（Product）**：要创建的复杂对象。

* **指挥者类（Director）**：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 

![建造者模式](E:\学习学习\Java学习资料\java设计者模式\第一章-02-创建者模式-工厂模式\笔记\img\建造者模式.png)
抽象建造者类：

``` java
// Director中控制顺序
public abstract Builder
{
    protected Product product = new Product();
    
    public abstract buildPartA();
    public abstract buildPartB();
    
	public abstract Product Product getResult();
}

// builder类中控制顺序(不太推荐，运用的是模板方法模式下文会提到)
public abstract Builder
{
    protected Product product = new Product();
    
    public abstract buildPartA();
    public abstract buildPartB();
    
	public Product getResult()
    {
        // 此处控制顺序
		this.buildPartB();
        this.builPartA();
        return product;
    }
}
```

具体建造者类

``` java
// Director中控制顺序
public class BuilderA extends builder
{
    
    @Override
	public void buildPartA()
    {
        product.name = "张三";
    }
    
    @Override
	public void buildPartB()
    {
        product.age = 18;
    }
    
    @Override
	public void Product getResult()
    {
        return product;
    }
}

// builder中定义顺序
public class BuilderA extends builder
{
    
    @Override
	public void buildPartA()
    {
        product.name = "张三";
    }
    
    @Override
	public void buildPartB()
    {
        product.age = 18;
    }
    
    // 父类中定义好了 getResult() 方法
}
```


产品类：
``` java
public class Product
{
    String name;
    int age;
}
```



指挥者类：
``` java
public class Director
{
    public static void main()
    {
        // Director中控制顺序
        BuilderA builder = new BuilderA();
        builder.builderPartA();	// 控制顺序
        builder.builderPartB();
        Product product = builder.getResult();
        
        // builder中定义顺序
       	BuilderA builder = new BuilderA();
        Product product = builder.getResult();	// 此方法在抽象类builder中已经定义好顺序。
    }
}
```



注意：建造者模式关注的是建造的 **顺序**  上面介绍了两种方式即：

- Builder 类中的 **getResult** 中通过调用本类的 buildPartA 和 builderPartB (加重了builder类的职责，不太推荐，但可以简化系统)
- Director类中的 **construct** 中通过调用 builder的 buidlPartA 和 bulderPartB



**优点：**

- 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。
- 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
- 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
- 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。

**缺点：**

造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

**拓展：**

``` java
public class Phone {

    private String cpu;
    private String screen;
    private String memory;
    private String mainboard;

    private Phone(Builder builder) 
    {
        cpu = builder.cpu;
        screen = builder.screen;
        memory = builder.memory;
        mainboard = builder.mainboard;
    }

    public static final class Builder 
    {
        private String cpu;
        private String screen;
        private String memory;
        private String mainboard;

        public Builder() {}

        public Builder cpu(String val) 
        {
            cpu = val;
            return this;
        }
        public Builder screen(String val) 
        {
            screen = val;
            return this;
        }
        public Builder memory(String val) 
        {
            memory = val;
            return this;
        }
        public Builder mainboard(String val) 
        {
            mainboard = val;
            return this;
        }
        public Phone build() 
        {
            return new Phone(this);
        }
    }
    @Override
    public String toString() {
        return "Phone{" +
                "cpu='" + cpu + '\'' +
                ", screen='" + screen + '\'' +
                ", memory='" + memory + '\'' +
                ", mainboard='" + mainboard + '\'' +
                '}';
    }
}

public class Client {
    public static void main(String[] args) {
        Phone phone = new Phone.Builder()
                .cpu("intel")
                .mainboard("华硕")
                .memory("金士顿")
                .screen("三星")
                .build();
        System.out.println(phone);
    }
}
```



## 总结对比

建造者模式 和 工厂模式非常像：都是把 **对象的常见移动到一个类中** ，不同的是 

- 工厂模式注重的是 **直接创建一个完整对象**。
- 建造模式注重的是 **创建对象的顺序** 



# 3. 行为型模式

用于描述如何将类或对象按某种布局组成更大的结构(**"流程控制"** 和 **”类间合作任务分配"**)

## 1. 模板方法模式(重点)

主要是利用抽象类，将公共代码定义在抽象类的具体方法中，不确定的功能定义为抽象方法由子类进行实现。同时可以定义模板方法在抽象类中，使得各个方法按照一定的顺序进行执行。

模板方法（Template Method）模式包含以下主要角色：

* 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。

  * **模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法(加final防止子类修改)。**

  * 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：

    * **抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。**

    * **具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。**

    * 钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。

      一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。

* 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。


![模板方法模式](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\模板方法模式.png)


 抽象类：
``` java
public abstract class AbstractClass 
{
    
    public final void cookProcess() 
    {
        //第一步：倒油(具体方法)
        this.pourOil();
        //第二步：热油(具体方法)
        this.heatOil();
        //第三步：倒蔬菜(抽象方法)
        this.pourVegetable();
        //第四步：倒调味料(抽象方法)
        this.pourSauce();
        //第五步：翻炒(具体方法)
        this.fry();
    }

    public void pourOil() 
    {
        System.out.println("倒油");
    }

    //第二步：热油是一样的，所以直接实现
    public void heatOil() 
    {
        System.out.println("热油");
    }

    //第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）
    public abstract void pourVegetable();

    //第四步：倒调味料是不一样
    public abstract void pourSauce();


    //第五步：翻炒是一样的，所以直接实现
    public void fry(){
        System.out.println("炒啊炒啊炒到熟啊");
    }
}
```


具体子类：

``` java
public class ConcreteClass_BaoCai extends AbstractClass 
{

    @Override
    public void pourVegetable() 
    {
        System.out.println("下锅的蔬菜是包菜");
    }

    @Override
    public void pourSauce() 
    {
        System.out.println("下锅的酱料是辣椒");
    }
}

public class ConcreteClass_CaiXin extends AbstractClass 
{
    @Override
    public void pourVegetable() 
    {
        System.out.println("下锅的蔬菜是菜心");
    }

    @Override
    public void pourSauce() 
    {
        System.out.println("下锅的酱料是蒜蓉");
    }
}
```



测试类：

``` java
public class Client 
{
    public static void main(String[] args) 
    {
        //炒手撕包菜
        ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai();
        baoCai.cookProcess();

        //炒蒜蓉菜心
        ConcreteClass_CaiXin caiXin = new ConcreteClass_CaiXin();
        caiXin.cookProcess();
    }
}
```

**注意：** 这里注重的是 **顺序**  上面的 建造者 模式也使用到了。

**优点：**

* 提高代码复用性

  将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。

* 实现了反向控制

  通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。

**缺点：**

* 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。
* 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。



## 2. 策略模式(重点)

封装一些列算法来调用不同的功能(类)，是他们可以相互替换，且算法的改变不会改变用户的体验。

通过多态，聚合一个抽象类，调用不同实现子类同一方法。

![image-20200210143039168](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\image-20200210143039168.png)

策略模式的主要角色如下：

* 抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
* 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。
* 环境（Context）类：持有一个策略类的引用，最终给客户端调用。

![策略模式](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\策略模式.png)


抽象策略：
 ``` java
 public interface Strategy
 {
     public abstract void show();
 }
 ```



具体策略：
```java
public class StrategyA implements Strategy
{
    @Override
	public void show() 
    {
        System.out.println(”我是策略A");
    }
}

public class StrategyB implements Strategy
{
    @Override
	public void show() 
    {
        System.out.println(”我是策略B");
    }
}
```



环境：

``` java
public void Client
{
    public Strategy strategy;
    
    public void Client(Strategy strategy)
    {
        this.strategy = strategy;
    }
    
    public void show()
    {
        strategy.show();
    }
}
```


优点：

* 策略类之间可以自由切换

  由于策略类都实现同一个接口，所以使它们之间可以自由切换。

* 易于扩展

  增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“

* 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。

缺点：

* 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
* 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。
  

### 拓展一. 工厂模式 + 策略模式 + 模板方法

解决上面必须知道所有策略类这一缺点，同时彻底解决了 If else 交替使用。

案例：
``` java
public class Client
{
    public void show(String key)
    {
        if (key.equals("A")) 
        {
            System.out.println("A的相关功能已经被调用！");
        } else if (key.equals("B")) {
            System.out.println("B的相关功能已经被调用!");
        } else if() {
            ``````
        } else if {
    		`````
        } else {
            throws new Exception("传入的参数有问题");
        }
    }
}
```

上面这种疯狂使用if else的代码成为 “屎山代码", 而且想用策略模式进行解决的话还是得事先进行判断，除非是直接传入一个策略对象然后调用其重写方法，但是显然此处不适用。

综上所述 策略模式存在许多的局限性，但多种策略模式结合可以解决此问题：

缓存工厂：
public class Factory
{
    private Map<String, Strategy> cache = new HashMap<>();
    
    public Strategy getStrategyFromCache(String key)
    {
        if (!map.containskey(key)) {
            return null;	// 传入参数在缓存中没有
        } 
        return map.get(key);
    }
    
    public void registerToCache(String key, Strategy strategy)	// 加入到缓存中
    {
        if (map.containsKey) return;
        
        map.put(key, strategy);
    }
}
```

 策略/模板 抽象类：
``` java
public Abstract Class Strategy implements InitializingBean
{
    public void preMethod()
    {
        System.out.println("我是前置处理方法!");
    }
    
    public void afterMethod()
    {
        System.out.println(”我是后置处理方法");
    }
    
	public void coreMethod();	// 核心方法，每个策略类都不同                       
    
	public void invoke()	// 定义模板方法
    {
        preMethod();
        coreMethod();
        afterMethod();
    }
}
```

具体策略类：

``` java
@Component
public class StrategyA extends Strategy
{
    @Override
	public void coremethod()
    {
        System.out.prinltn("A方法的和新方法");
    }
    
    @Override
	public void afterPropertiesSet()	// InitializingBean接口：bean初始化的时候加载
    {
        if (Factory.getStrategyFromCache() == null) .
        {
            Factory.registerToCache("A", this);
        }
    }
}
```


调用类：
``` java
public class Client
{
    public void show(String key)
    {
		Strategy strategy = Factory.getStrategyFromCache(key);	// 调用工厂从换从中取Strategy
        if (strategy == null)	// 判空
        {
            System.out.println(”传入无效key");
        }
        strategy.invoke();	// 调用模板方法
    }
}
```



优点：

- 解决了必须知道所有策略，才能准确调用策略。
- 避免了大量使用 If else
- 可以使用对应的 Flag(可以是String等带标记的性质类型) 获取对应的 startegy，增加了策略模式的实用性。



注意：

将Strategy加入到缓存：

- 这里使用的是 InitializingBean接口 实现其 bean初始化之前方法加入。
- 使用反射机制进 + 调用对应的方法进行加入。



## 3. 命令模式

将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。

注意：**命令**得具有请求执行的**所有条件**，比如聚合了最终**命令接受者**(一般必须有)，同时可以聚合其它辅助类。

![命令模式](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\命令模式.png)

* 抽象命令类（Command）角色： 定义命令的接口，声明**执行**的方法。
* 具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有**接收者**，并调用接收者的功能来完成命令要执行的操作。
* 实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
* 调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有**命令对象**，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。



调用逻辑为：
**调用者** --- 调用---> **具体命令** --- 调用---> **实现者**

抽象命令类：

``` java
public interface Command {
    void execute();//只需要定义一个统一的执行方法
}
```

具体命令类：

``` java
public class OrderCommand implements Command {

    //持有接受者对象 和 订单 等命令执行的必要条件。
    private SeniorChef receiver;
    private Order order;

    public OrderCommand(SeniorChef receiver, Order order){
        this.receiver = receiver;
        this.order = order;
    }

    public void execute()  {
        System.out.println(order.getDiningTable() + "桌的订单：");
        Set<String> keys = order.getFoodDic().keySet();
        for (String key : keys) {
            receiver.makeFood(order.getFoodDic().get(key),key);
        }

        try {
            Thread.sleep(100);//停顿一下 模拟做饭的过程
        } catch (InterruptedException e) {
            e.printStackTrace();
        }


        System.out.println(order.getDiningTable() + "桌的饭弄好了");
    }
}
```

订单类（业务需求）：
``` java
public class Order {
    // 餐桌号码
    private int diningTable;

    // 用来存储餐名并记录份数
    private Map<String, Integer> foodDic = new HashMap<String, Integer>();

    public int getDiningTable() {
        return diningTable;
    }

    public void setDiningTable(int diningTable) {
        this.diningTable = diningTable;
    }

    public Map<String, Integer> getFoodDic() {
        return foodDic;
    }

    public void setFoodDic(String name, int num) {
        foodDic.put(name,num);
    }
}
```

实现者类：

``` java
public class SeniorChef {

    public void makeFood(int num,String foodName) {
        System.out.println(num + "份" + foodName);
    }
}
```

调用者：
``` java
public class Waitor {

    private ArrayList<Command> commands;//可以持有很多的命令对象

    public Waitor() {
        commands = new ArrayList();
    }
    
    public void setCommand(Command cmd){
        commands.add(cmd);
    }

    // 发出命令 喊 订单来了，厨师开始执行
    public void orderUp() {
        System.out.println("美女服务员：叮咚，大厨，新订单来了.......");
        for (int i = 0; i < commands.size(); i++) {
            Command cmd = commands.get(i);
            if (cmd != null) {
                cmd.execute();
            }
        }
    }
}
```

测试类：
```java
public class Client {
    public static void main(String[] args) {
        //创建2个order
        Order order1 = new Order();
        order1.setDiningTable(1);
        order1.getFoodDic().put("西红柿鸡蛋面",1);
        order1.getFoodDic().put("小杯可乐",2);

        Order order2 = new Order();
        order2.setDiningTable(3);
        order2.getFoodDic().put("尖椒肉丝盖饭",1);
        order2.getFoodDic().put("小杯雪碧",1);

        //创建接收者
        SeniorChef receiver=new SeniorChef();
        //将订单和接收者封装成命令对象
        OrderCommand cmd1 = new OrderCommand(receiver, order1);
        OrderCommand cmd2 = new OrderCommand(receiver, order2);
        //创建调用者 waitor
        Waitor invoker = new Waitor();
        invoker.setCommand(cmd1);
        invoker.setCommand(cmd2);

        //将订单带到柜台 并向厨师喊 订单来了
        invoker.orderUp();
    }
}
```

**优点：**

* 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
* 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
* 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
* 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。

**缺点：**

* 使用命令模式可能会导致某些系统有过多的具体命令类。
* 系统结构更加复杂。

**注意：**

- **命令**得具有请求执行的**所有条件**，比如聚合了最终**命令接受者**(一般必须有)，同时可以聚合其它业务逻辑必须的类。



## 4. 责任链模式

就是通过链表结构进行 事务 判断和处理，将每个 Handler处理者 抽象成一个个 链表节点，通过设置相关的 类的实例变量 进行判断。

* 抽象处理者（Handler）角色：定义一个**处理请求**的接口，包含判断变量、抽象处理方法和一个后继连接。
* 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，**判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者**。
* 客户类（Client）角色：**创建处理链**，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

![责任链模式](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\责任链模式.png)

抽象处理者类:
``` java
public abstract class Handler
{
    public int startTime;	// 判断实例变量
    public int endTime;
    
    public Handler nextHandler;	// 下一个节点
    
    public void excute(LeaveRequest request)
    {
        if (request.time >= this.startTime)	// 达到本处理范围，进行处理
        {
            this.handleRequest(request);
        }
        
        if (null != thie.nextHandler && request.time > this.endTime) // 判断是否需要传递到下个处理
        {
            this.nextHandler.excute(request);
        }
        
        System.out.println("流程处理完毕！");
    }
    
    public abstract void handleRequest();	// 本类的抽象处理方法(这里可以改成返回boolean从而进行判断是进入下一个节点)
    
    public Handler(int startTime, int endTime)	// 构造器
    {
        this.startTime = startTime;
        this.endTime = endTime;
    }
}
```


具体处理类：
``` java
public class GroupLeader extends Handler
{
    public GroupLeader(int startTime, int endTime)
    {
        supser(startTime, endTime);
    }
    
    @Override
	public void handleRequest()
    {
        System.out.println("组长进行判断并通过！");
    }
}

public class Manager extends Handler
{
    public Manager(int startTime, int endTime)
    {
        supser(startTime, endTime);
    }
    
    @Override
	public void handleRequest()
    {
        System.out.println("经理进行判断并通过！");
    }
}

public class GeneralManager extends Handler
{
    public GeneralManager(int startTime, int endTime)
    {
        supser(startTime, endTime);
    }
    
    @Override
	public void handleRequest()
    {
        System.out.println("部门经理进行判断并通过！");
    }
}
```


Client客户类：

``` java
public class Client
{
    public static void main(int []args)
    {
        Hanlder groupLeader = new GroupLeader(1, 3);
        Handler manager = new Manager(3, 7);
        Handler generalManager = new GeneralManager(7, Integer.MAX_VALUE);	// 兜底Handler
        
        groupLeader.nextHandler = manager;
        manager.nextHandler = generalManager;
        
        LeaveRequest request = new LeaveRequest(4, "家里有事请假四天");
       	groupLeader.excute(request);
    }
}
```

**优点：**

* 降低了对象之间的耦合度

  该模式降低了请求发送者和接收者的耦合度。

* 增强了系统的可扩展性

  可以根据需要增加新的请求处理类，满足开闭原则。

* 增强了给对象指派职责的灵活性

  当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。

* 责任链简化了对象之间的连接

  一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。

* 责任分担

  每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。

**缺点：**

* 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。
* 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
* 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。

**注意：**

- 一般最后一个节点为兜底节点,防止一个时间经过整个链路后都没有进行处理。

  

## 5. 状态模式

​	根据 实例类的**状态**属性 判断当前 实力类对应方法的执行。

![状态模式前](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\状态模式前.png)

- 抽象状态类：定义 状态常量 和 抽象方法，且方法会根据状态的不同而执行结果不同。
- 具体状态类：实现上面 抽象方法。

抽象状态类：

``` java
public interface ILift {
    //电梯的4个状态
    //开门状态
    public final static int OPENING_STATE = 1;
    //关门状态
    public final static int CLOSING_STATE = 2;
    //运行状态
    public final static int RUNNING_STATE = 3;
    //停止状态
    public final static int STOPPING_STATE = 4;

    //设置电梯的状态
    public void setState(int state);

    //电梯的动作
    public void open();
    public void close();
    public void run();
    public void stop();
}
```

具体状态类：
``` java
public class Lift implements ILift {
    private int state;

    @Override
    public void setState(int state) {
        this.state = state;
    }

    //执行关门动作
    @Override
    public void close() {
        switch (this.state) {
            case OPENING_STATE:
                System.out.println("电梯关门了。。。");//只有开门状态可以关闭电梯门，可以对应电梯状态表来看
                this.setState(CLOSING_STATE);//关门之后电梯就是关闭状态了
                break;
            case CLOSING_STATE:
                //do nothing //已经是关门状态，不能关门
                break;
            case RUNNING_STATE:
                //do nothing //运行时电梯门是关着的，不能关门
                break;
            case STOPPING_STATE:
                //do nothing //停止时电梯也是关着的，不能关门
                break;
        }
    }

    //执行开门动作
    @Override
    public void open() {
        switch (this.state) {
            case OPENING_STATE://门已经开了，不能再开门了
                //do nothing
                break;
            case CLOSING_STATE://关门状态，门打开:
                System.out.println("电梯门打开了。。。");
                this.setState(OPENING_STATE);
                break;
            case RUNNING_STATE:
                //do nothing 运行时电梯不能开门
                break;
            case STOPPING_STATE:
                System.out.println("电梯门开了。。。");//电梯停了，可以开门了
                this.setState(OPENING_STATE);
                break;
        }
    }

    //执行运行动作
    @Override
    public void run() {
        switch (this.state) {
            case OPENING_STATE://电梯不能开着门就走
                //do nothing
                break;
            case CLOSING_STATE://门关了，可以运行了
                System.out.println("电梯开始运行了。。。");
                this.setState(RUNNING_STATE);//现在是运行状态
                break;
            case RUNNING_STATE:
                //do nothing 已经是运行状态了
                break;
            case STOPPING_STATE:
                System.out.println("电梯开始运行了。。。");
                this.setState(RUNNING_STATE);
                break;
        }
    }

    //执行停止动作
    @Override
    public void stop() {
        switch (this.state) {
            case OPENING_STATE: //开门的电梯已经是是停止的了(正常情况下)
                //do nothing
                break;
            case CLOSING_STATE://关门时才可以停止
                System.out.println("电梯停止了。。。");
                this.setState(STOPPING_STATE);
                break;
            case RUNNING_STATE://运行时当然可以停止了
                System.out.println("电梯停止了。。。");
                this.setState(STOPPING_STATE);
                break;
            case STOPPING_STATE:
                //do nothing
                break;
        }
    }
}
```

客户调用类：

``` java
public class Client {
    public static void main(String[] args) {
        Lift lift = new Lift();
        lift.setState(ILift.STOPPING_STATE);//电梯是停止的
        lift.open();//开门
        lift.close();//关门
        lift.run();//运行
        lift.stop();//停止
    }
}
```


缺点：

* 使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。
* 扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑

优点：

- 没啥优点，除了严谨。



## 6. 观察者模式

又被称为 发布者订阅模式 一对多依赖，一个 subject主题 被多个 object对象 进行观察。
即一个subject主题包含多个object对象，对他们进行发布信息。

![观察者模式](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\观察者模式.png)

在观察者模式中有如下角色：

* Subject：抽象主题（**抽象被观察者**），抽象主题角色**把所有观察者对象保存在一个集合**里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。

* ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。

* Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。

* ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。

  

定义抽象观察者类：

```java
public interface Observer {
    void update(String message);
}
```

具体观察者：

```java
public class WeixinUser implements Observer {
    // 微信用户名
    private String name;

    public WeixinUser(String name) {
        this.name = name;
    }
    @Override
    public void update(String message) {
        System.out.println(name + "-" + message);
    }
}
```

抽象主题：

```java
public interface Subject {
    //增加订阅者
    public void attach(Observer observer);

    //删除订阅者
    public void detach(Observer observer);
    
    //通知订阅者更新消息
    public void notify(String message);
}
```

具体主题：

```java
public class SubscriptionSubject implements Subject {
    //储存订阅公众号的微信用户
    private List<Observer> weixinUserlist = new ArrayList<Observer>();

    @Override
    public void attach(Observer observer) {
        weixinUserlist.add(observer);
    }

    @Override
    public void detach(Observer observer) {
        weixinUserlist.remove(observer);
    }

    @Override
    public void notify(String message) {
        for (Observer observer : weixinUserlist) {
            observer.update(message);
        }
    }
}
```

客户端程序

```java
public class Client {
    public static void main(String[] args) {
        SubscriptionSubject mSubscriptionSubject=new SubscriptionSubject();
        //创建微信用户
        WeixinUser user1=new WeixinUser("孙悟空");
        WeixinUser user2=new WeixinUser("猪悟能");
        WeixinUser user3=new WeixinUser("沙悟净");
        //订阅公众号
        mSubscriptionSubject.attach(user1);
        mSubscriptionSubject.attach(user2);
        mSubscriptionSubject.attach(user3);
        //公众号更新发出消息给订阅的微信用户
        mSubscriptionSubject.notify("传智黑马的专栏更新了");
    }
}
```

**优点：**

* 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。
* 被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】

**缺点：**

* 如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时
* 如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃



## 7. 中介者模式

如果多个同事类之间相互调用的话，关系会很复杂，耦合度会很高。如果利用一个中介者类进行合理的分配就会将 网状结构     优化成 星形结构。

![image-20200214110924010](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\image-20200214110924010.png)

中介者模式包含以下主要角色：

* 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。

* 具体中介者（ConcreteMediator）角色：实现中介者接口，**定义一个 List 来管理同事对象**，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
* 抽象同事类（Colleague）角色：定义同事类的接口，**保存中介者对象**，提供**同事对象交互的抽象方法**，实现所有相互影响的同事类的公共功能。
* 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。

![中介者模式](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\中介者模式.png)



**注意：** 终结者聚合了需要互相调用的所有同时类，每个同时类同样聚合了中介类(实际上不进行聚合也行，可以直接调用);

终结者类：

``` java
//抽象中介者
public abstract class Mediator {
    //申明一个联络方法
    public abstract void constact(String message,Person person);
}
```

具体终结者：
``` java
public class MediatorStructure extends Mediator {
    //首先中介结构必须知道所有房主和租房者的信息
    private HouseOwner houseOwner;
    private Tenant tenant;

    public HouseOwner getHouseOwner() {
        return houseOwner;
    }

    public void setHouseOwner(HouseOwner houseOwner) {
        this.houseOwner = houseOwner;
    }

    public Tenant getTenant() {
        return tenant;
    }

    public void setTenant(Tenant tenant) {
        this.tenant = tenant;
    }

    public void constact(String message, Person person) {
        if (person == houseOwner) {          //如果是房主，则租房者获得信息
            tenant.getMessage(message);
        } else {       						//反则是房主获得信息
            houseOwner.getMessage(message);
        }
    }
}
```

抽象同事类：
``` java
//抽象同事类
public abstract class Person {
    protected String name;
    protected Mediator mediator;	// 聚合了中介类

    public Person(String name,Mediator mediator){
        this.name = name;
        this.mediator = mediator;
    }
}
```

具体同事类：
``` java
//具体同事类 房屋拥有者
public class HouseOwner extends Person {

    public HouseOwner(String name, Mediator mediator) {
        super(name, mediator);
    }

    //与中介者联系
    public void constact(String message){
        mediator.constact(message, this);
    }

    //获取信息
    public void getMessage(String message){
        System.out.println("房主" + name +"获取到的信息：" + message);
    }
}

//具体同事类 承租人
public class Tenant extends Person {
    public Tenant(String name, Mediator mediator) {
        super(name, mediator);
    }

    //与中介者联系
    public void constact(String message){
        mediator.constact(message, this);
    }

    //获取信息
    public void getMessage(String message){
        System.out.println("租房者" + name +"获取到的信息：" + message);
    }
}
```

测试类：

``` java
//测试类
public class Client {
    public static void main(String[] args) {
        //一个房主、一个租房者、一个中介机构
        MediatorStructure mediator = new MediatorStructure();

        //房主和租房者只需要知道中介机构即可
        HouseOwner houseOwner = new HouseOwner("张三", mediator);
        Tenant tenant = new Tenant("李四", mediator);

        //中介结构要知道房主和租房者
        mediator.setHouseOwner(houseOwner);
        mediator.setTenant(tenant);

        tenant.constact("需要租三室的房子");
        houseOwner.constact("我这有三室的房子，你需要租吗？");
    }
}
```

**优点：**

* 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。
* 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。
* 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。

**缺点：**

增加了类的个数，这在一定程度上增加了系统的复杂性。



## 8. 迭代器模式

提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 可以参考 ArrayList.iterator() 方法。
聚合类添加元素到集合中，并返回迭代器对象。迭代器包含 next，hasNext方法。

迭代器模式主要包含以下角色：

* 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及**创建迭代器对象的接口(一般为getIterator()**。

* 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。（如List)
* 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。
* 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。

![迭代器模式](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\迭代器模式.png)

抽象迭代器：

```java
public interface StudentIterator {
    boolean hasNext();
    Student next();
}
```

具体的迭代器类：

```java
public class StudentIteratorImpl implements StudentIterator {
    private List<Student> list;
    private int position = 0;

    public StudentIteratorImpl(List<Student> list) {
        this.list = list;
    }

    @Override
    public boolean hasNext() {
        return position < list.size();
    }

    @Override
    public Student next() {
        Student currentStudent = list.get(position);
        position ++;
        return currentStudent;
    }
}
```

抽象聚合：

```java
public interface StudentAggregate {
    void addStudent(Student student);

    void removeStudent(Student student);

    StudentIterator getStudentIterator();
}
```

具体聚合：

```java
public class StudentAggregateImpl implements StudentAggregate {

    private List<Student> list = new ArrayList<Student>();  // 学生列表

    @Override
    public void addStudent(Student student) {
        this.list.add(student);
    }

    @Override
    public void removeStudent(Student student) {
        this.list.remove(student);
    }

    @Override
    public StudentIterator getStudentIterator() {
        return new StudentIteratorImpl(list);
    }
}
```

测试类：
``` java
public class Client
{
    public static void main(int []args)
    {
    	StudentAggregate aggregate = new StudentAggregateImpl();
        aggregate.add(new Student("zs", 19));
        aggregate.add(new Student("ls", 18));
        
        StudentIterator iterator = aggregate.getStudentIterator();
        while (iterator.hasNext())
        {
            System.out.println(iterator.next());
        }
    }
}
```



## 9. 访问者模式

元素(被访问者)通过定义 Accept(访问者对象)方法 接受访问者，并调用 访问者对象 action(this) 的方法。

访问者定义对应的action(被访问者对象)，访问对象。

对象结构：一个容器，里面包含 访问者 和 元素(被访问者)list，然后进行统一调用。

访问者模式包含以下主要角色:

* 抽象访问者（Visitor）角色：定义了对每一个元素`（Element）`访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。
* 具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。
* 抽象元素（Element）角色：定义了一个接受访问者的方法（`accept`），其意义是指，每一个元素都要可以被访问者访问。
* 具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。
* 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（`Element具体元素`），并且可以迭代这些元素，供访问者访问。

![访问者模式](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\访问者模式.png)

创建抽象访问者接口

```java
public interface Person {
    void feed(Cat cat);

    void feed(Dog dog);
}
```

创建不同的具体访问者角色（主人和其他人），都需要实现 `Person`接口

```java
public class Owner implements Person {

    @Override
    public void feed(Cat cat) {
        System.out.println("主人喂食猫");
    }

    @Override
    public void feed(Dog dog) {
        System.out.println("主人喂食狗");
    }
}

public class Someone implements Person {
    @Override
    public void feed(Cat cat) {
        System.out.println("其他人喂食猫");
    }

    @Override
    public void feed(Dog dog) {
        System.out.println("其他人喂食狗");
    }
}
```

抽象元素(被访问者):

```java
public interface Animal {
    void accept(Person person);
}
```

具体元素：

```java
public class Dog implements Animal {

    @Override
    public void accept(Person person) {
        person.feed(this);
        System.out.println("好好吃，汪汪汪！！！");
    }
}

public class Cat implements Animal {

    @Override
    public void accept(Person person) {
        person.feed(this);
        System.out.println("好好吃，喵喵喵！！！");
    }
}
```

对象结构：

```java
public class Home {
    private List<Animal> nodeList = new ArrayList<Animal>();

    public void action(Person person) {
        for (Animal node : nodeList) {
            node.accept(person);
        }
    }

    //添加操作
    public void add(Animal animal) {
        nodeList.add(animal);
    }
}

```

测试类

```java
public class Client {
    public static void main(String[] args) {
        Home home = new Home();
        home.add(new Dog());
        home.add(new Cat());

        Owner owner = new Owner();
        home.action(owner);

        Someone someone = new Someone();
        home.action(someone);
    }
}
```

**优点：**

* 扩展性好

  在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。

* 复用性好

  通过访问者来定义整个对象结构通用的功能，从而提高复用程度。

* 分离无关行为

  通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。

**缺点：**

* 对象结构变化很困难

  在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。

* 违反了依赖倒置原则

  访问者模式依赖了具体类，而没有依赖抽象类。(因为这里使用的是方法的**重载**，访问者类中重载feed)


**注意：**

- 重载：静态分派，看左边
- 重写：动态分派，看右边
- 双分派：我们这里用了 重写 覆盖了 重载，实现了动态分派(看右边);



## 10. 备忘录模式

创建一个 备忘录类 保存状态，创建一个管理类保存 备忘录 类，发起人为被保存的对象。

备忘录模式的主要角色如下：

* 发起人（Originator）角色：记录当前时刻的内部状态信息，**提供创建备忘录和恢复备忘录数据的功能**，实现其他业务功能，**它可以访问备忘录里的所有信息**。
* 备忘录（Memento）角色：负责**存储发起人的内部状态**，在需要的时候提供这些内部状态给发起人。
* 管理者（Caretaker）角色：对备忘录进行管理，**提供保存与获取备忘录的功能**，但其不能对备忘录的内容进行访问与修改。

1. 宽接口实现(所有人都可以访问备忘录里信息)

   ![白箱备忘录模式](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\白箱备忘录模式.png)

发起人：
``` java
//游戏角色类
public class GameRole {
    private int vit; //生命力
    private int atk; //攻击力
    private int def; //防御力

    //初始化状态
    public void initState() {
        this.vit = 100;
        this.atk = 100;
        this.def = 100;
    }

    //战斗
    public void fight() {
        this.vit = 0;
        this.atk = 0;
        this.def = 0;
    }

    //保存角色状态
    public RoleStateMemento saveState() {
        return new RoleStateMemento(vit, atk, def);
    }

    //回复角色状态
    public void recoverState(RoleStateMemento roleStateMemento) {
        this.vit = roleStateMemento.getVit();
        this.atk = roleStateMemento.getAtk();
        this.def = roleStateMemento.getDef();
    }

    public void stateDisplay() {
        System.out.println("角色生命力：" + vit);
        System.out.println("角色攻击力：" + atk);
        System.out.println("角色防御力：" + def);
    }
}
```



备忘录：
``` java
//游戏状态存储类(备忘录类)
public class RoleStateMemento {
    private int vit;
    private int atk;
    private int def;

    public RoleStateMemento(int vit, int atk, int def) {
        this.vit = vit;
        this.atk = atk;
        this.def = def;
    }
}
```


管理者：
``` java

//角色状态管理者类
public class RoleStateCaretaker {
    private RoleStateMemento roleStateMemento;

    public RoleStateMemento getRoleStateMemento() {
        return roleStateMemento;
    }

    public void setRoleStateMemento(RoleStateMemento roleStateMemento) {
        this.roleStateMemento = roleStateMemento;
    }
}
```

测试类：
``` java
public class Client {
    public static void main(String[] args) {
        System.out.println("------------大战Boss前------------");
        //大战Boss前
        GameRole gameRole = new GameRole();
        gameRole.initState();
        gameRole.stateDisplay();

        //保存进度
        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();
        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());

        System.out.println("------------大战Boss后------------");
        //大战Boss时，损耗严重
        gameRole.fight();
        gameRole.stateDisplay();
        System.out.println("------------恢复之前状态------------");
        //恢复之前状态
        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());
        gameRole.stateDisplay();

    }
}
```



2. 窄接口(将备忘录类为发起人类子类，提供接口供外人访问)

   ![黑箱备忘录模式](E:\学习学习\Java学习资料\java设计者模式\第三章-04-行为型模型\笔记\img\黑箱备忘录模式.png)

窄接口`Memento`，这是一个标识接口，因此没有定义出任何的方法

```java
public interface Memento {
}
```

定义发起人类 `GameRole`，并在内部定义备忘录内部类 `RoleStateMemento`（该内部类设置为私有的）

```java
/游戏角色类
public class GameRole {
    private int vit; //生命力
    private int atk; //攻击力
    private int def; //防御力

    //初始化状态
    public void initState() {
        this.vit = 100;
        this.atk = 100;
        this.def = 100;
    }

    //战斗
    public void fight() {
        this.vit = 0;
        this.atk = 0;
        this.def = 0;
    }

    //保存角色状态
    public Memento saveState() {
        return new RoleStateMemento(vit, atk, def);	// 返回内部接口
    }

    //回复角色状态
    public void recoverState(Memento memento) {
        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;
        this.vit = roleStateMemento.getVit();
        this.atk = roleStateMemento.getAtk();
        this.def = roleStateMemento.getDef();
    }

    public void stateDisplay() {
        System.out.println("角色生命力：" + vit);
        System.out.println("角色攻击力：" + atk);
        System.out.println("角色防御力：" + def);

    }

    private class RoleStateMemento implements Memento {	// 备忘录类
        private int vit;
        private int atk;
        private int def;

        public RoleStateMemento(int vit, int atk, int def) {
            this.vit = vit;
            this.atk = atk;
            this.def = def;
        }
    }
}
```

管理者类：

```java
public class RoleStateCaretaker {
    private Memento memento;

    public Memento getMemento() {
        return memento;
    }

    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
```

端测试类

```java
public class Client {
    public static void main(String[] args) {
        System.out.println("------------大战Boss前------------");
        //大战Boss前
        GameRole gameRole = new GameRole();
        gameRole.initState();
        gameRole.stateDisplay();

        //保存进度
        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();
        roleStateCaretaker.setMemento(gameRole.saveState());
        
        System.out.println("------------大战Boss后------------");
        //大战Boss时，损耗严重
        gameRole.fight();
        gameRole.stateDisplay();
        System.out.println("------------恢复之前状态------------");
        //恢复之前状态
        gameRole.recoverState(roleStateCaretaker.getMemento());
        gameRole.stateDisplay();
    }
}

```





**优点：**

- 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
- 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
- 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。

**缺点：**

* 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。



# 4. 结构模式

## 1. 代理模式(重点)

分为两种代理：

- 静态代理：聚合对应的类 并 实现对应抽象类(为了实现对应方法)。调用聚合的类的方法实现代理，并可以附加功能。
- 动态代理：上面静态代理是 *写死* 的，每次增加一个功能就得重写对应的代理类，而动态代理是动态调用的(利用发射)。
  - jdk动态代理：基于 *接口* 实现的动态代理。
  - cglib动态代理：基于 *类* 实现的动态代理。



代理（Proxy）模式分为三种角色：

* **抽象主题（Subject）**类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。
* **真实主题（Real Subject）**类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
* **代理（Proxy）类** ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

![静态代理](E:\学习学习\Java学习资料\java设计者模式\第二章-03-结构型模型\笔记\img\静态代理.png)

**静态代理：**

抽象主题：

``` java
//卖票接口
public interface SellTickets {
    void sell();
}
```

真实主题：
``` java
public class TrainStation implements SellTickets {

    public void sell() {
        System.out.println("火车站卖票");
    }
}
```

代理类：
```java
public class ProxyPoint implements SellTickets {

    private TrainStation station = new TrainStation();

    public void sell() {
        System.out.println("代理点收取一些服务费用");
        station.sell();
    }
}
```



**jdk动态代理**：基于接口抽象方法进行反射代理。

抽象主题：

``` java
//卖票接口
public interface SellTickets {
    void sell();
}
```

真实主题：

``` java
public class TrainStation implements SellTickets {

    public void sell() {
        System.out.println("火车站卖票");
    }
}
```

代理类：使用的是Proxy.newProxyInstance(加载器，接口，InvocationHandler调用方法)。

``` java
public class ProxyFactory {

    private TrainStation station = new TrainStation();

    public SellTickets getProxyObject() {
        //使用Proxy获取代理对象
        /*
            newProxyInstance()方法参数说明：
                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可
                Class<?>[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口
                InvocationHandler h ： 代理对象的调用处理程序
         */
        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),
                station.getClass().getInterfaces(),
                new InvocationHandler() {
                    /*
                        InvocationHandler中invoke方法参数说明：
                            proxy ： 代理对象
                            method ： 对应于在代理对象上调用的接口方法的 Method 实例
                            args ： 代理对象调用接口方法时传递的实际参数
                     */
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

                        System.out.println("代理点收取一些服务费用(JDK动态代理方式)");
                        Object result = method.invoke(station, args);	// 反射进行
                        return result;
                    }
                });
        return sellTickets;
    }
}
```



**cglib动态代理：**基于类进行反射代理，所以没有接口类。

导入第三方jar包：

``` java
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>2.2.2</version>
</dependency>
```

真实主题：

``` java
public class TrainStation {

    public void sell() {
        System.out.println("火车站卖票");
    }
}
```

代理工厂：
``` java
public class ProxyFactory implements MethodInterceptor {

    private TrainStation target = new TrainStation();

    public TrainStation getProxyObject() {
        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数
        Enhancer enhancer =new Enhancer();
        //设置父类的字节码对象
        enhancer.setSuperclass(target.getClass());
        //设置回调函数
        enhancer.setCallback(this);
        //创建代理对象
        TrainStation obj = (TrainStation) enhancer.create();
        return obj;
    }

    /*
        intercept方法参数说明：
            o ： 代理对象
            method ： 真实对象中的方法的Method实例
            args ： 实际参数
            methodProxy ：代理对象中的方法的method实例
     */
    public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println("代理点收取一些服务费用(CGLIB动态代理方式)");
        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);
        return result;
    }
}
```



**三种代理模式对比：**

* jdk代理和CGLIB代理

  使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。

  在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以**如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理**。

* 动态代理和静态代理

  动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。

  如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题

**注意：**
代理上面的代理返回的都是类，具体还得调用对应的方法，例如：

``` java
public class Client {
    public static void main(String[] args) {
        //获取代理对象
        ProxyFactory factory = new ProxyFactory();
        SellTickets proxyObject = factory.getProxyObject();
        proxyObject.sell();
    }
}
```

**优点：**

- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
- 代理对象可以扩展目标对象的功能；
- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；

**缺点：**

* 增加了系统的复杂度；

**使用场景：**

* 远程（Remote）代理

  本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。

* 防火墙（Firewall）代理

  当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。

* 保护（Protect or Access）代理

  控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。



## 2. 适配器模式(重点)

![转接头](E:\学习学习\Java学习资料\java设计者模式\第二章-03-结构型模型\笔记\img\转接头.png)

将一个类的接口转换成用户希望的接口，**适配器**必须实现对应的目标接口类(为了实现对应的方法)，然后根据继承类进行调用**被转换类**，直接传入被**转换类对象**，分为：

- 类适配器模式
- 对象适配器模式



适配器模式（Adapter）包含以下主要角色：

* 目标（Target）接口：当前系统业务所**期待**的接口，它可以是抽象类或接口(我们希望转换的结果)。
* 适配者（Adaptee）类：它是**被**访问和适配的现存组件库中的组件接口(需要被适配的类)。
* 适配器（Adapter）类：它是一个**转换器**，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。



**类适配器模式：**

![适配器模式](E:\学习学习\Java学习资料\java设计者模式\第二章-03-结构型模型\笔记\img\适配器模式.png)

目标接口：
``` java
//SD卡的接口
public interface SDCard {
    //读取SD卡方法
    String readSD();
    //写入SD卡功能
    void writeSD(String msg);
}

//SD卡实现类
public class SDCardImpl implements SDCard {
    public String readSD() {
        String msg = "sd card read a msg :hello word SD";
        return msg;
    }

    public void writeSD(String msg) {
        System.out.println("sd card write msg : " + msg);
    }
}
```

适配者类：
``` java
//TF卡接口
public interface TFCard {
    //读取TF卡方法
    String readTF();
    //写入TF卡功能
    void writeTF(String msg);
}

//TF卡实现类
public class TFCardImpl implements TFCard {

    public String readTF() {
        String msg ="tf card read msg : hello word tf card";
        return msg;
    }

    public void writeTF(String msg) {
        System.out.println("tf card write a msg : " + msg);
    }
}
```

适配器：
``` java
//定义适配器类（SD兼容TF）
public class SDAdapterTF extends TFCardImpl implements SDCard {

    public String readSD() {
        System.out.println("adapter read tf card ");
        return readTF();
    }

    public void writeSD(String msg) {
        System.out.println("adapter write tf card");
        writeTF(msg);
    }
}
```

电脑类：
``` java
//电脑类
public class Computer {

    public String readSD(SDCard sdCard) {
        if(sdCard == null) {
            throw new NullPointerException("sd card null");
        }
        return sdCard.readSD();
    }
}
```

测试类：
``` java
//测试类
public class Client {
    public static void main(String[] args) {
        Computer computer = new Computer();
        SDCard sdCard = new SDCardImpl();
        System.out.println(computer.readSD(sdCard));

        System.out.println("------------");

        SDAdapterTF adapter = new SDAdapterTF();
        System.out.println(computer.readSD(adapter));
    }
}
```



**对象适配器模式：**
![对象适配器模式](E:\学习学习\Java学习资料\java设计者模式\第二章-03-结构型模型\笔记\img\对象适配器模式.png)

适配器类：只需要经适配者对象传入适配器类中。
``` java
//创建适配器对象（SD兼容TF）
public class SDAdapterTF  implements SDCard {

    private TFCard tfCard;

    public SDAdapterTF(TFCard tfCard) {
        this.tfCard = tfCard;
    }

    public String readSD() {
        System.out.println("adapter read tf card ");
        return tfCard.readTF();
    }

    public void writeSD(String msg) {
        System.out.println("adapter write tf card");
        tfCard.writeTF(msg);
    }
}
```

**应用场景：**

* 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
* 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。



## 3. 装饰者模式

反例：大量运用继承。
![装饰者模式-使用前](E:\学习学习\Java学习资料\java设计者模式\第二章-03-结构型模型\笔记\img\装饰者模式-使用前.png)



装饰者模式进行改造：(将继承改成聚合)

![装饰者模式](E:\学习学习\Java学习资料\java设计者模式\第二章-03-结构型模型\笔记\img\装饰者模式.png)

装饰（Decorator）模式中的角色：

* 抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象(被装饰者抽象类)。
* 具体构件（Concrete  Component）角色 ：实现**抽象构件**，通过装饰角色为其添加一些职责(被装饰者具体类)。
* 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含**具体构件**的实例，可以通过其子类扩展具体构件的功能。
* 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给**具体构件**对象添加附加的责任。

**装饰抽象类** 继承或实现 **抽象构建(重写或继承对应的方法因为是在基础上进行装饰加强)** 并聚合 **抽象构建实例(传入被加强的实例)** 
然后实现 **具体装饰类** 传递 **具体构建** 和 **数据初始化继承抽象构建类** 实现对传入的 **具体构建的加强作用。**



抽象构件：

``` java
//快餐接口
public abstract class FastFood {
    private float price;
    private String desc;

    public FastFood() {
    }

    public FastFood(float price, String desc) {
        this.price = price;
        this.desc = desc;
    }
}
```

具体构件：
``` java
//炒饭
public class FriedRice extends FastFood {

    public FriedRice() {
        super(10, "炒饭");
    }

    public float cost() {
        return getPrice();
    }
}

//炒面
public class FriedNoodles extends FastFood {

    public FriedNoodles() {
        super(12, "炒面");
    }

    public float cost() {
        return getPrice();
    }
}
```

抽象装饰：继承被装饰类接口，聚合对应实现类。
``` java
//配料类
public abstract class Garnish extends FastFood {

    private FastFood fastFood;

    public FastFood getFastFood() {
        return fastFood;
    }

    public void setFastFood(FastFood fastFood) {
        this.fastFood = fastFood;
    }

    public Garnish(FastFood fastFood, float price, String desc) {
        super(price,desc);
        this.fastFood = fastFood;
    }
}
```

具体构建：

``` java
//鸡蛋配料
public class Egg extends Garnish {

    public Egg(FastFood fastFood) {
        super(fastFood,1,"鸡蛋");
    }

    public float cost() {
        return getPrice() + getFastFood().getPrice();
    }

    @Override
    public String getDesc() {
        return super.getDesc() + getFastFood().getDesc();
    }
}

//培根配料
public class Bacon extends Garnish {

    public Bacon(FastFood fastFood) {

        super(fastFood,2,"培根");
    }

    @Override
    public float cost() {
        return getPrice() + getFastFood().getPrice();
    }

    @Override
    public String getDesc() {
        return super.getDesc() + getFastFood().getDesc();
    }
}
```

测试类：
``` java
//测试类
public class Client {
    public static void main(String[] args) {
        //点一份炒饭
        FastFood food = new FriedRice();
        //花费的价格
        System.out.println(food.getDesc() + " " + food.cost() + "元");

        System.out.println("========");
        //点一份加鸡蛋的炒饭
        FastFood food1 = new FriedRice();

        food1 = new Egg(food1);
        //花费的价格
        System.out.println(food1.getDesc() + " " + food1.cost() + "元");

        System.out.println("========");
        //点一份加培根的炒面
        FastFood food2 = new FriedNoodles();
        food2 = new Bacon(food2);
        //花费的价格
        System.out.println(food2.getDesc() + " " + food2.cost() + "元");
    }
}
```

**静态代理和装饰者模式的区别：**

* 相同点：
  * 都要实现与目标类相同的业务接口
  * 在两个类中都要声明目标对象
  * 都可以在不修改目标类的前提下增强目标方法
* 不同点：
  * 目的不同
    装饰者是为了增强目标对象
    静态代理是为了保护和隐藏目标对象
  * 获取目标对象构建的地方不同
    装饰者是由外界传递进来，可以通过构造方法传递
    静态代理是在代理类内部创建，以此来隐藏目标对象

**好处：**

* 饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。

* 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

**使用场景：**

* 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。

  不能采用继承的情况主要有两类：

  * 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；
  * 第二类是因为类定义不能继承（如final类）

* 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。

* 当对象的功能要求可以动态地添加，也可以再动态地撤销时。



## 4. 桥接模式

反例：现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系。
![image-20200207194617620](E:\学习学习\Java学习资料\java设计者模式\第二章-03-结构型模型\笔记\img\image-20200207194617620.png)

**桥接模式优化：**向上 **抽象**，并聚合。
需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了**两个维度（操作系统，文件）**，适合使用桥接模式。

![桥接模式](E:\学习学习\Java学习资料\java设计者模式\第二章-03-结构型模型\笔记\img\桥接模式.png)

桥接（Bridge）模式包含以下主要角色：

* 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。
* 扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
* 实现化（Implementor）角色 ：定义**实现化角色**的接口，供扩展**抽象化角色**调用。
* 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。

适用于两个 **对象**， 将两个对象关联起来。

抽象化（Abstraction）角色 ：定义抽象类，并聚合一个对**实现化对象**的引用。



实现化角色：

``` java
//视频文件
public interface VideoFile {
    void decode(String fileName);
}
```

具体实现化：

``` java
//avi文件
    public class AVIFile implements VideoFile {
        public void decode(String fileName) {
            System.out.println("avi视频文件："+ fileName);
        }
    }

//rmvb文件
public class REVBBFile implements VideoFile {

    public void decode(String fileName) {
        System.out.println("rmvb文件：" + fileName);
    }
}
```

抽象化：
``` java
//操作系统版本
public abstract class OperatingSystemVersion {

    protected VideoFile videoFile;

    public OperatingSystemVersion(VideoFile videoFile) {
        this.videoFile = videoFile;
    }

    public abstract void play(String fileName);
}
```

扩展抽象化：

``` java
//Windows版本
public class Windows extends OperatingSystemVersion {

    public Windows(VideoFile videoFile) {
        super(videoFile);
    }

    public void play(String fileName) {
        videoFile.decode(fileName);
    }
}

//mac版本
public class Mac extends OperatingSystemVersion {

    public Mac(VideoFile videoFile) {
        super(videoFile);
    }

    public void play(String fileName) {
		videoFile.decode(fileName);
    }
}
```

测试类：

```java
//测试类
public class Client {
    public static void main(String[] args) {
        OperatingSystem os = new Windows(new AVIFile());
        os.play("战狼3");
    }
}
```

**好处：**

* 桥接模式提高了系统的可扩充性，在**两个变化维度**中任意扩展一个维度，都不需要修改原有系统。

  如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。

* 实现细节对客户透明

**使用场景**

* 当一个类存在**两个独立变化的维度**，且这两个维度都需要进行扩展时。
* 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
* 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。

## 5. 外观模式

又名门面模式，是一种通过为多个复杂的子系统**提供一个一致的接口**，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。
![外观模式引入](E:\学习学习\Java学习资料\java设计者模式\第二章-03-结构型模型\笔记\img\外观模式引入.jpg)

外观（Facade）模式包含以下主要角色：

* 外观（Facade）角色：为多个**子系统**对外提供一个共同的接口。
* 子系统（Sub System）角色：实现系统的部分功能，客户可以通过**外观角色**访问它。



外观类：
``` java
//智能音箱
public class SmartAppliancesFacade {

    private Light light;
    private TV tv;
    private AirCondition airCondition;

    public SmartAppliancesFacade() {
        light = new Light();
        tv = new TV();
        airCondition = new AirCondition();
    }

    public void say(String message) {
        if(message.contains("打开")) {
            on();
        } else if(message.contains("关闭")) {
            off();
        } else {
            System.out.println("我还听不懂你说的！！！");
        }
    }

    //起床后一键开电器
    private void on() {
        System.out.println("起床了");
        light.on();
        tv.on();
        airCondition.on();
    }

    //睡觉一键关电器
    private void off() {
        System.out.println("睡觉了");
        light.off();
        tv.off();
        airCondition.off();
    }
}
```

子系统：

``` java
//灯类
public class Light {
    public void on() {
        System.out.println("打开了灯....");
    }

    public void off() {
        System.out.println("关闭了灯....");
    }
}

//电视类
public class TV {
    public void on() {
        System.out.println("打开了电视....");
    }

    public void off() {
        System.out.println("关闭了电视....");
    }
}
```

测试类：

``` java
public class Test {
    public static void main(String[] args) {
        //创建外观对象
        SmartAppliancesFacade facade = new SmartAppliancesFacade();
        //客户端直接与外观对象进行交互
        facade.say("打开家电");
        facade.say("关闭家电");
    }
}
```

**使用场景：**

* 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。
* 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。
* 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。



## 6. 组合模式

又名部分整体模式，是用于把一组**相似的对象(叶子节点，树枝节点)**当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

组合模式主要包含三种角色：

* 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。
* 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。
* 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。



抽象根节点：

``` java
//菜单组件  不管是菜单还是菜单项，都应该继承该类
public abstract class MenuComponent {

    protected String name;
    protected int level;

    //添加菜单
    public void add(MenuComponent menuComponent){
        throw new UnsupportedOperationException();
    }

    //移除菜单
    public void remove(MenuComponent menuComponent){
        throw new UnsupportedOperationException();
    }

    //获取指定的子菜单
    public MenuComponent getChild(int i){
        throw new UnsupportedOperationException();
    }

    //获取菜单名称
    public String getName(){
        return name;
    }

    public void print(){
        throw new UnsupportedOperationException();
    }
}
```



树枝节点：

``` java
public class Menu extends MenuComponent {

    private List<MenuComponent> menuComponentList;

    public Menu(String name,int level){
        this.level = level;
        this.name = name;
        menuComponentList = new ArrayList<MenuComponent>();
    }

    @Override
    public void add(MenuComponent menuComponent) {
        menuComponentList.add(menuComponent);
    }

    @Override
    public void remove(MenuComponent menuComponent) {
        menuComponentList.remove(menuComponent);
    }

    @Override
    public MenuComponent getChild(int i) {
        return menuComponentList.get(i);
    }

    @Override
    public void print() {

        for (int i = 1; i < level; i++) {
            System.out.print("--");
        }
        System.out.println(name);
        for (MenuComponent menuComponent : menuComponentList) {
            menuComponent.print();
        }
    }
}
```



叶子节点：
``` java
public class MenuItem extends MenuComponent {

    public MenuItem(String name,int level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public void print() {
        for (int i = 1; i < level; i++) {
            System.out.print("--");
        }
        System.out.println(name);
    }
}
```

MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。

**优点：**

* 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
  * 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。
* 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。
* 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。

**注意：**在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。

* 透明组合模式

  透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 `MenuComponent` 声明了 `add`、`remove` 、`getChild` 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。

  透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）

* 安全组合模式

  在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 `Menu` 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。



## 7. 享元模式

​	运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。

享元（Flyweight ）模式中存在以下两种状态：

1. 内部状态，即不会随着环境的改变而改变的可共享部分。
2. 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。

享元模式的主要有以下角色：

* 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。
* 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。
* 非享元（Unsharable Flyweight)角色 ：并不是所有的**抽象享元类**的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。
* 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的**享元对象**，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。



抽象享元对象：
``` java
public abstract class AbstractBox {
    public abstract String getShape();

    public void display(String color) {
        System.out.println("方块形状：" + this.getShape() + " 颜色：" + color);
    }
}
```

具体享元对象：
``` java
public class IBox extends AbstractBox {

    @Override
    public String getShape() {
        return "I";
    }
}

public class LBox extends AbstractBox {

    @Override
    public String getShape() {
        return "L";
    }
}

public class OBox extends AbstractBox {

    @Override
    public String getShape() {
        return "O";
    }
}
```

享元工厂：使用了 *单例(静态内部类)*  + map 进行实现
``` java
public class BoxFactory {

    private static HashMap<String, AbstractBox> map;

    private BoxFactory() {
        map = new HashMap<String, AbstractBox>();
        AbstractBox iBox = new IBox();
        AbstractBox lBox = new LBox();
        AbstractBox oBox = new OBox();
        map.put("I", iBox);
        map.put("L", lBox);
        map.put("O", oBox);
    }

    public static final BoxFactory getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final BoxFactory INSTANCE = new BoxFactory();
    }

    public AbstractBox getBox(String key) {
        return map.get(key);
    }
}
```

**优点**

- 极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能
- 享元模式中的外部状态相对独立，且不影响内部状态

**缺点：**

为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂

**使用场景：**

- 一个系统有大量相同或者相似的对象，造成内存的大量耗费。
- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
- 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。
